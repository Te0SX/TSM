import datetime

from django.core.exceptions import ValidationError
from django.db import models
from django.contrib.auth.models import User

# Job roles user worked during a shift, like tutor, researcher etc
class Roles(models.Model):
    name = models.CharField('Type of role', max_length=120)         # name of the role
    hourlyPay = models.IntegerField('Payment per hour for a role')  # payment per hour, like 7$/hr

    def hourlyPayment(self):
        return self.hourlyPay

    def __str__(self):
        return self.name

# Model for a Shift, that is being added to student timesheets.
class Shift(models.Model):
    studentID = models.ForeignKey(User, blank=True, null=True, on_delete=models.CASCADE)    # owner of the shift
    date = models.DateTimeField('Date added', auto_now_add=True)            # date added to timesheet
    role = models.ForeignKey(Roles, null=True, on_delete=models.SET_NULL)   # role of the job
    startHour = models.DateTimeField('Time started working')                # Start of the shift
    endHour = models.DateTimeField('Time finished working')                 # End of the shift
    verified = models.BooleanField(default=False)                           # if shift has been verified
    paid = models.BooleanField(default=False)                               # if shift has been paid

    def payment(self):
        time = self.endHour - self.startHour                                 #calculate time working
        payment = round(self.role.hourlyPay * time.seconds / 60 / 60,2)      #hourlyPay * hours worked, rounded for 2 demicals
        return payment

    def clean(self, *args, **kwargs):
        if self.startHour > self.endHour :
            # Error message appears in case Start is later than End
            raise ValidationError('Start of the Shift is not earlier than the End of the Shift')
        return super().clean(*args, **kwargs)

    def __str__(self):
        return str(self.studentID)

# Model for Salary and payments
class Salary(models.Model):
    studentID = models.ForeignKey(User, blank=True, null=True, on_delete=models.CASCADE)   # owner of payment
    date = models.DateTimeField('Date added', auto_now_add=True)        # date payment happened
    amount = models.FloatField('Amount paid', default=0)                # amount paid

    def __int__(self):
        return self.amount

# model of Message, for verifier to get in touch with student in case of a mistake. User can resolve messages.
class Message(models.Model):
    sender = models.ForeignKey(User, related_name="sender", on_delete=models.CASCADE)       # Sender of the message
    receiver = models.ForeignKey(User, related_name="receiver", on_delete=models.CASCADE)   # Receiver
    msg_title = models.CharField("Title", max_length=50)                            # Title of the message, autogenerated including shift id
    msg_content = models.CharField("Content of message", max_length=3000)           # content, written by sender
    sender_role = models.CharField("Role of Sender", max_length=50)                 # what role the sender has
    date = models.DateTimeField('Date added', auto_now_add=True)                    # date the message was sent
    read = models.BooleanField(default=False)                   # if the message has been read
    resolved =  models.BooleanField(default=False)              # if the message has been resolved

    def __str__(self):
        return str(self.receiver)